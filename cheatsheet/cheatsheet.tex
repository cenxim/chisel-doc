\documentclass[10pt,landscape]{article}
\usepackage{multicol}
\usepackage[landscape]{geometry}
\usepackage[procnames]{listings}
\usepackage[parfill]{parskip}
\usepackage{fixltx2e}

\input{scala.tex}

% Remove section numbering
\setcounter{secnumdepth}{0}

\geometry{top=1cm,left=1cm,right=1cm,bottom=1cm}

\pagestyle{empty}

\begin{document}
\begin{multicols}{3}

\begin{center}
\Large{Chisel Cheat Sheet}
\end{center}

\renewcommand{\tabcolsep}{.5mm}

\section{Notation}
\verb$c, x, y$ are Chisel types; \verb$n, m$ are Scala integers \newline
\verb$wx, wy$ are the widths of \verb$x, y$ (respectively) \newline
\verb$minVal(x)$, \verb$maxVal(x)$ are the min or max of \verb$x$ \newline
\verb$s$ is a Scala string; \verb$b$ is a Scala boolean \newline
\verb$[ ... ]$ in functions are optional arguments

\section{Basic Operators}
\begin{tabular}{l l}
\verb$val x = UInt()$ & Allocate \verb$a$ as \verb$UInt()$ \\
\verb$val x := y$ & Re-assign \verb$y$ to \verb$x$ \\
\verb$x <> y$ & Connect \verb$x$ and \verb$y$, inferring direction \\
\end{tabular}

\section{Basic Data Types}
\subsection{Bool Constructors}
\begin{tabular}{l l l}
\verb$Bool()$ & Create an un-assigned wire \\
\verb$Bool(b)$ & Create a literal \\
\end{tabular}

\subsection{Bits, SInt, UInt Constructors}
Constructors also applicable for \verb$UInt$, \verb$SInt$ \newline
\begin{tabular}{l l}
\verb$Bits([width=n])$ & Create an un-assigned wire \\
\verb$Bits(x=n, [width=m])$ & Create a literal from integer \\
\verb$Bits(x=s, [width=m])$ & Create a literal from string \\
\end{tabular}

\subsection{Bits, UInt, SInt Casts}
\begin{tabular}{l l}
\verb$UInt$ to \verb$SInt$ & zero-extend to SInt \\
all others & reinterpret cast \\
\end{tabular}

\subsection{Bool Operators}
\begin{tabular}{l l l}
Chisel & Explanation & Width \\
\hline
\hline
\verb$!x$ & Logical NOT & \verb$1$ \\
\verb$x && y$ & Logical AND & \verb$1$ \\
\verb$x || y$ & Logical OR & \verb$1$ \\
\end{tabular}

\subsection{Bits Operators}
\begin{tabular}{l l l}
Chisel & Explanation & Width \\
\hline
\hline
\verb$x(n)$ & Extract bit (0 is LSB) & \verb$1$ \\
\verb$x(n, m)$ & Extract bitfield & \verb$n - m + 1$ \\
\verb$x << y$ & Left shift & \verb$wx + maxVal(y)$ \\
\verb$x >> y$ & Right shift & \verb$wx - minVal(y)$ \\
\verb$x << n$ & Left shift & \verb$wx + n$ \\
\verb$x >> n$ & Right shift & \verb$wx - n$ \\
\verb$Fill(n, x)$ & Replicate \verb$x$ \verb$n$ times & \verb$n * wx$ \\
\verb$Cat(x, y)$ & Concatenate bitfields & \verb$wx + wy$ \\
\verb$Mux(c, x, y)$ & If \verb$c$ then \verb$x$ else \verb$y$ & \verb$max(wx, wy)$ \\
\hline
\verb$~x$ & Bitwise NOT & \verb$wx$ \\
\verb$x & y$ & Bitwise AND & \verb$max(wx, wy)$ \\
\verb$x | y$ & Bitwise OR & \verb$max(wx, wy)$ \\
\verb$x ^ y$ & Bitwise XOR & \verb$max(wx, wy)$ \\
\hline
\verb$x === y$ & Equality & \verb$1$ \\
\verb$x != y$ & Inequality & \verb$1$ \\
\hline
\verb$andR(x)$ & AND-reduce & \verb$1$ \\
\verb$orR(x)$ & OR-reduce & \verb$1$ \\
\verb$xorR(x)$ & XOR-reduce & \verb$1$ \\
\end{tabular}

\subsection{UInt, SInt Operators}
Bitwidths only valid for UInt operations

\begin{tabular}{l l l}
Chisel & Explanation & Width \\
\hline
\hline
\verb$x + y$ & Addition & \verb$max(wx, wy)$ \\
\verb$x - y$ & Subtraction & \verb$max(wx, wy)$ \\
\verb$x * y$ & Multiplication & \verb$wx + wy$ \\
\verb$x / y$ & Division & \verb$wx$ \\
\verb$x % y$ & Modulus & \verb$bits(maxVal(y) - 1)$ \\
\hline
\verb$x > y$ & Greater than & \verb$1$ \\
\verb$x >= y$ & Greater than or equal & \verb$1$ \\
\verb$x < y$ & Less than & \verb$1$ \\
\verb$x <= y$ & Less than or equal & \verb$1$ \\
\hline
\verb$x >> y$ & Arithmetic right shift & \verb$wx - minVal(y)$ \\
\verb$x >> n$ & Arithmetic right shift & \verb$wx - n$ \\
\end{tabular}

\section{Helpers}
\subsection{When}
Use \verb$when$ to execute statements conditionally \newline
\verb$when$ behaves similarly to Verilog \newline \verb$always @(posedge clk)$
\begin{scala}
when(condition1) {
	// run if condition1 true
} .elsewhen(condition2) {
	// run if condition2 true
} .unless(condition3) {
	// run if condition3 false
} .otherwise {
	// run if none of the above true
}
\end{scala}

\subsection{Switch}
Use \verb$switch$ to execute statements conditionally \newline
on the value of a wire \newline
\begin{scala}
switch(x) {
	is(value1) {
		// run if x === value1
	} is(value2) {
		// run if x === value2
	}
}
\end{scala}

\subsection{Enum}
Use \verb$enum$s to generate list values \newline
\verb$val s1::s2::$...\verb$::s$\textsubscript{n}\verb$::Nil := Enum(t, n)$ \newline
where \verb$t$ is an empty Chisel wire (i.e. \verb$Bits()$) \newline
and \verb$n$ is the number of values \newline
and \verb$s1$, \verb$s2$, ..., \verb$s$\textsubscript{n} will have distinct values

\section{Aggregate Types}
\subsection{Bundle}

\subsection{Vec}

\section{State Elements}
\subsection{Registers}

\subsection{Memory}

\section{Modules}

\section{Scala Hardware Generation}
\subsection{For}

\subsection{If}

\subsection{Functional Abstraction}

\section{Standard Library}
\subsection{Decoupled}
\subsection{PipeIO}
\subsection{Arbiter}
\subsection{RRAArbiter}


\end{multicols}
\end{document}
