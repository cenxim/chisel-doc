\documentclass[10pt,twocolumn]{article}
\setlength\textwidth{6.875in}
\setlength\textheight{8.875in}
% set both margins to 2.5 pc
\setlength{\oddsidemargin}{-0.1875in}% 1 - (8.5 - 6.875)/2
\setlength{\evensidemargin}{-0.1875in}
\setlength{\marginparwidth}{0pc}
\setlength{\marginparsep}{0pc}%
\setlength{\topmargin}{0in} \setlength{\headheight}{0pt}
\setlength{\headsep}{0pt}
\setlength{\footskip}{37pt}%
\setlength{\columnsep}{0.3125in}
\setlength{\columnwidth}{3.28125in}% (6.875 - 0.3125)/2 = 3.28125in
\setlength{\parindent}{1pc}
\newcommand{\myMargin}{1.00in}
\usepackage[top=\myMargin, left=\myMargin, right=\myMargin, bottom=\myMargin, nohead]{geometry}
\usepackage{epsfig,graphicx}
\usepackage{palatino}
\usepackage{fancybox}
\usepackage[procnames]{listings}

\newenvironment{commentary}
{ \vspace{-0.1in}
  \begin{quotation}
  \noindent
  \small \em
  \rule{\linewidth}{1pt}\\
}
{
  \end{quotation}
}

\title{Chisel Manual}
\author{Jonathan Bachrach, Krste Asanovi\'{c} \\
EECS Department, UC Berkeley\\
{\tt  \{jrb|krste\}@eecs.berkeley.edu}
}
\date{\today}

\newenvironment{example}{\VerbatimEnvironment\begin{footnotesize}\begin{Verbatim}}{\end{Verbatim}\end{footnotesize}}
\newcommand{\kode}[1]{\begin{footnotesize}{\tt #1}\end{footnotesize}}

\def\code#1{{\small\tt #1}}

\def\note#1{\noindent{\bf [Note: #1]}}
%\def\note#1{}

\input{../style/scala.tex}

\lstset{frame=}

\begin{document}
\maketitle{}

% TODO: default
% TODO: enum yields Bits
% TODO: why hardware construction languages



\section{Introduction}

This document is a manual for {\em Chisel} (Constructing
Hardware In a Scala Embedded Language).  Chisel is a hardware
construction language embedded in the high-level programming language
Scala.  Chisel is really only a set of special class
definitions, predefined objects, and usage conventions within Scala,
so when you write a Chisel program you are actually writing a Scala
program.  For this manual we presume that you
understand the basics of Scala.  
We recommend you consult one of the excellent
Scala books before reading this manual.

\section{Nodes}

Chisel user code creates a graph of nodes which Chisel then translates
into Verilog or C++ code.  Nodes are defined as follows:

\begin{lstlisting}
class Node {
  // name assigned by user or from introspection
  var name: String = ""
  // incoming graph edges
  def inputs: ArrayBuffer[Node]
  // outgoing graph edges
  def consumers: ArrayBuffer[Node]
  // node specific width inference
  def inferWidth: Int
  // get width immediately inferrable
  def getWidth: Int
  // get first raw node
  def getRawNode: Node
  // convert to raw bits 
  def toBits: Bits
  // convert to raw bits 
  def fromBits(x: Bits): this.type
  // return lit value if inferrable else null
  def litOf: Lit
}
\end{lstlisting}


The topmost node class hierarchy is shown in
Figure~\ref{fig:node-hierarchy}.  The basic categories are:

\begin{description}
\item[Lit] -- constants or literals,
\item[Op] -- logical or arithmetic operations,
\item[Updateable] -- conditionally updated nodes,
\item[Data] -- typed wires or ports,
\item[Reg] -- positive-edge-triggered registers, and
\item[Mem] -- memories.
\end{description}

\begin{figure}[h]
\centering
\includegraphics[width=3in]{figs/node-hierarchy.pdf}
\caption{Node hierarchy.}
\label{fig:node-hierarchy}
\end{figure}

\section{Lits}

Raw literals are represented as \code{Lit} nodes defined as follows:

\begin{lstlisting}
class Lit extends Node {
  val inputVal: BigInt;
}
\end{lstlisting}

\noindent
where \code{inputVal} is the value used to create the literal.  
Raw literals contain a collection of bits.  
Users do not create raw lits directly, but instead use type
constructors defined in Section~\ref{sec:types}.

% Constant or literal values are expressed using Scala integers or strings passed to constructors for the types:

% TODO: isLit and litOf

\section{Ops}

Raw operations are represented as \code{Op} nodes defined as follows:

\begin{lstlisting}
class Op extends Node {
  val op: String;
}
\end{lstlisting}

\noindent
where \code{op} holds the op name used during emission.  
Ops compute a combinational function of their inputs.

\section{Types}
\label{sec:types}

A Chisel graph contains raw and type nodes.  Type nodes are
interspersed between raw nodes and allow Chisel code to
check and respond to Chisel types.  Type nodes are erased before
emission to C++ and Verilog.  \code{Data} is the top most type node
and Figure~\ref{fig:type-hierarchy} shows the built in type hierarchy.

\begin{figure}[h]
\centering
\includegraphics[height=2.5in]{figs/type-hierarchy.pdf}
\caption{Type hierarchy.}
\label{fig:type-hierarchy}
\end{figure}

\noindent
Builtin scalar types include \code{Bits}, \code{Bool}, \code{Fix}, and
\code{UFix} and builtin aggregate types \code{Bundle} and \code{Vec}
are classes that allow the user to expand
the set of Chisel datatypes with collections of other types.

\code{Data} itself is a node:

\begin{lstlisting}
abstract class Data extends Node {
  override def clone(): this.type =
    this.getClass.newInstance.
      asInstanceOf[this.type];
  // simple conversions
  def toFix: Fix;
  def toUFix: UFix;
  def toBool: Bool;
  def toBits: Bits;
  // data leaves if aggregate
  def leaves: Array[(String, Data)];
  // port direction if leaf
  def dir: PortDir;
  // change dir to OUTPUT
  def asOutput: this.type;
  // change dir to INPUT
  def asInput: this.type;
  // change polarity of dir
  def flip: this.type;
  // assign to input
  def :=[T <: Data](t: T);
  // bulk assign to input
  def <>(t: Data);
}
\end{lstlisting}

\noindent
with methods for converting between types and 
delegating port methods to its single input.   
We will discuss ports in Section~\ref{sec:ports}.
Finally, users can override the \code{clone} method in their own type nodes (e.g., bundles) in
order to reflect construction parameters that are necessary for cloning.

Data nodes can be used for four purposes:

\begin{itemize}
\item {\bf types} -- \kode{UFix(width = 8)} -- record intermediate types in the graph
  specifying at minimum bitwidth (described in this section), 
\item {\bf wires} -- \kode{UFix(width = 8)} -- serve as forward declarations of data allowing future
  conditional updates (described in Section~\ref{sec:wires}), 
\item {\bf ports} -- \kode{UFix(width = 8, dir = OUTPUT)} -- are specialized wires defining component interfaces
  additionally specifying direction (described in
  Section~\ref{sec:ports}), and
\item{\bf literals} -- \kode{UFix(1)} or \kode{UFix(1, 8)} -- can be constructed using type object
constructors specifying their value and optional width.
\end{itemize}

\subsection{Bits}

In Chisel, a raw collection of bits is represented by the \code{Bits} type defined as follows:

\begin{lstlisting}
object Bits {
  def apply(width: Int = -1): Bits;
  // create literal
  def apply(value: BigInt, width: Int = -1): Bits;
}

class Bits extends Data {
  def unary_-(): Bits;
  def unary_~(): Bits;
  def &  (b: Bits): Bits;
  def |  (b: Bits): Bits;
  def ^  (b: Bits): Bits;
  def andR(): Bool;
  def orR():  Bool;
  def && (b: Bool): Bool;
  def || (b: Bool): Bool;
  def ===(b: Bits): Bool;
  def != (b: Bits): Bool;
  def << (b: UFix): Bits;
  def >> (b: UFix): Bits;
  def ## (b: Bits): Bits;
}

object Cat {
  def apply[T <: Data](elt: T, elts: T*): Bits;
}
\end{lstlisting}

\noindent
with methods for simple bit operations.  
Bits with a value argument produces a \code{Lit} as shown in Figure~\ref{fig:bits-1}.
N.B., that \code{\#\#} is binary
concatenation, \code{Cat} is an nary concatentation,
and in order to not collide with Scala's builtin \code{==},
Chisel's bitwise comparison is named \code{===}.

Operations produce an actual operator node and a type node combining the input type nodes.
See Figures~\ref{fig:bits-1}, \ref{fig:bits-and}, \ref{fig:bits-or-and} for
successively more complicated examples.

\begin{figure}[h]
\centering
\includegraphics[height=1in]{figs/bits-1.pdf}
\caption{Chisel graph representing {\tt\footnotesize Bits(1)}.}
\label{fig:bits-1}
\end{figure}

\begin{figure}[h]
\centering
\includegraphics[height=1.5in]{figs/bits-and.pdf}
\caption{Chisel graph representing {\tt\footnotesize Bits(1)\&Bits(2)}.}
\label{fig:bits-and}
\end{figure}

\begin{figure}[h]
\centering
\includegraphics[height=2.5in]{figs/bits-or-and.pdf}
\caption{Chisel graph representing 
  {\tt\footnotesize (Bits(1)\&Bits(2))|Bits(3)} augmenting the graph
  shown in Figure~\ref{fig:bits-and}.}
\label{fig:bits-or-and}
\end{figure}

\noindent
The \code{getRawNode} operator will skip type nodes and return the first
raw node.

\subsection{Bools}

Boolean values are represented as \code{Bool}s:

\begin{lstlisting}
object Bool {
  def apply():Bool;
  def apply(value: Boolean): Bool;
}

class Bool extends Bits;
\end{lstlisting}

\subsection{Nums}

\code{Num} is a type node which defines arithmetic operations:

\begin{lstlisting}
class Num extends Bits {
  def +(b: Num): Num;
  def *(b: Num): Num;
  def -(b: Num): Num;
  def >(b: Num): Bool;
  def <(b: Num): Bool;
  def <=(b: Num): Bool;
  def >=(b: Num): Bool;
}
\end{lstlisting}

Signed and unsigned integers
are considered subsets of fixed-point numbers and are represented by
types \code{Fix} and \code{UFix} respectively:

\begin{lstlisting}
object Fix {
  def apply(width: Int = -1):Fix;
  def apply(value: BigInt, width: Int = -1): Fix;
}

class Fix extends Num; 

object UFix {
  def apply(width: Int = -1):UFix;
  def apply(value: BigInt, width: Int = -1): UFix;
}

class UFix extends Num; 
\end{lstlisting}

\noindent
Signed fixed-point
numbers, including integers, are represented using two's-complement
format.  

\subsection{Bundles}

Bundles group together several named fields of potentially different
types into a coherent unit, much like a \code{struct} in C:

\begin{lstlisting}
class Bundle extends Data {
  // shallow named bundle elements
  def elements: ArrayBuffer[(String, Data)];
}
\end{lstlisting}

\noindent
A user can get the name and type corresponding to each element in a
Bundle with the \code{elements} method and recursively using the
\code{leaves} method. 
Users can define their own by subclassing \code{Bundle} as follows:

\begin{lstlisting}
class MyFloat extends Bundle {
  val sign        = Bool();
  val exponent    = Bits(width = 8);
  val significand = Bits(width = 23);
}

val x  = new MyFloat()
val xs = x.sign
\end{lstlisting}

\subsection{Vecs}

Vecs create an indexable vector of elements: 

\begin{lstlisting}
object Vec {
  def apply[T <: Data](n: Int)(gen: => T): Vec[T];
}

class Vec[T <: Data](n: Int, val gen: () => T) 
    extends Data {
  def apply(idx: UFix): T
  def apply(idx: Int): T
}
\end{lstlisting}

\noindent
with \code{n} elements of type defined with the \code{gen} thunk.
Users can then either dynamically (using a \code{UFix}) or statically (using
an \code{Int} accessed the elements,
where dynamic access creates a virtual type node (representing a read
``port'') that records the read using the given address.  In either case,
users can wire to the result of a read as follows:

\begin{lstlisting}
v(a) := d;
\end{lstlisting}

% TODO: conditionally assigning to elements

\subsection{Bit Width Inference}

Users are required to set bitwidths of ports and registers, but otherwise,
bit widths on nodes are automatically inferred unless set manually by the user.
% TODO: how do you set the width explicitly?
The bit-width inference engine starts from the graph's input ports and 
calculates node output bit widths from their respective input bit widths according to the following set of rules:\\

{\footnotesize
\begin{tabular}{ll}
{\bf operation} & {\bf bit width} \\ 
\verb|z = x + y| & \verb|wz = max(wx, wy) + 1| \\
\verb+z = x - y+ & \verb|wz = max(wx, wy) + 1|\\
\verb+z = x & y+ & \verb+wz = max(wx, wy)+ \\
\verb+z = Mux(c, x, y)+ & \verb+wz = max(wx, wy)+ \\
\verb+z = w * y+ & \verb!wz = wx + wy! \\
\verb+z = x << n+ & \verb!wz = wx + maxNum(n)! \\
\verb+z = x >> n+ & \verb+wz = wx - minNum(n)+ \\
\verb+z = Cat(x, y)+ & \verb!wz = wx + wy! \\
\verb+z = Fill(n, x)+ & \verb+wz = wx * maxNum(n)+ \\
% \verb+z = x < y+ & \verb+<= > >= && || != ===+ & \verb+wz = 1+ \\
\end{tabular}
}
\\[1mm]
\noindent  
where for instance $wz$ is the bit width of wire $z$, and the \verb+&+
rule applies to all bitwise logical operations.

The bit-width inference process continues until no bit width changes.
Except for right shifts by known constant amounts, the bit-width
inference rules specify output bit widths that are never smaller than
the input bit widths, and thus, output bit widths either grow or stay
the same.  Furthermore, the width of a register must be specified by
the user either explicitly or from the bitwidth of the reset value.
From these two requirements, we can show that the bit-width inference
process will converge to a fixpoint.

\section{Updateables}

\label{sec:wires}

When describing the operation of wire and state
nodes, it is often useful to instead specify when updates to the
wires and state will occur and to specify these updates spread across
several separate statements.  
For example, Data nodes can be used immediately, but their input set later.
\code{Updateable} is conditionally updateable and 
collects accesses and code generates a mux input for the node:

\begin{lstlisting}
abstract class Updateable extends Node {
  // conditional reads
  def reads: Queue[(Bool, UFix)];
  // conditional writes
  def writes: Queue[(Bool, UFix, Node)];
  // gen mux integrating all conditional writes
  def genMuxes(default: Node);
  override def := (x: Node): this.type;
}
\end{lstlisting}

Chisel provides conditional update rules
in the form of the \code{when} construct to support this style of
sequential logic description:
 
\begin{lstlisting}
object when {
  def apply(cond: Bool)(block: => Unit): when;
}

class when (prevCond: Bool) {
  def elsewhen (cond: Bool)(block: => Unit): when;
  def otherwise (block: => Unit): Unit;
}
\end{lstlisting}

% TODO: talk about conds

Chisel provides some syntactic sugar for other common forms of
conditional updates:

\begin{lstlisting}
object unless {
  def apply(c: Bool)(block: => Unit) = 
    when (!c) { block )
}
\end{lstlisting}

\noindent 
and

\begin{lstlisting}
object otherwise {
  def apply(block: => Unit) = 
    when (Bool(true)) { block }
}
\end{lstlisting}

We introduce the \code{switch} statement for conditional updates
involving a series of comparisons against a common key:

\begin{lstlisting}
object switch {
  def apply(c: Bits)(block: => Unit): Unit;
}
object is {
  def apply(v: Bits)(block: => Unit);
}
\end{lstlisting}

\section{Ports}
\label{sec:ports}

Ports are \code{Data} derived nodes used as interfaces to hardware
components.   A port is a directional version of a primitive
\code{Data} object.  Port directions are defined as follows:

\begin{lstlisting}
trait PortDir;
object INPUT  extends PortDir;
object OUTPUT extends PortDir;
\end{lstlisting}

\noindent
Aggregate ports can be recursively constructed using either a vec or
bundle with instances of \code{Port}s as leaves.  

\section{Regs}

The simplest form of state element supported by Chisel is a
positive-edge-triggered register defined as follows:

\begin{lstlisting}
object Reg {
  def apply[T <: Data]
        (data: T, resetVal: T = null): T;
  def apply[T <: Data] (resetVal: T): T;
  def apply[T <: Data] ()(gen: => T): T;
}
 
class Reg extends Updateable;
\end{lstlisting}

\noindent
where they can be constructed as follows:

\begin{lstlisting}
val r1 = Reg(io.in);
val r2 = Reg(resetVal = UFix(1, 8));
val r3 = Reg(data = io.in, resetVal = UFix(1));
val r4 = Reg(){ UFix(width = 8) };
\end{lstlisting}

\section{Mems}

Chisel provides facilities for creating both read only and
read/write memories.  

\begin{lstlisting}
object Mem {
  def apply[T <: Data](depth: Int)(gen: => T): T;
}

class Mem[T <: Data](n: Int, gen: () => T) 
    extends Updateable {
  def apply(idx: UFix): T;
}

class MemRead[T <: Data]
      (val mem: Mem, val idx: UFix) 
    extends Node {
  override def := (data: T): T;
}

class MemWrite[T <: Data]
      (val mem: Mem, val idx: UFix, val kind: T) 
    extends Node;
\end{lstlisting}

\noindent
where a \code{:=} method on \code{MemRead} permits the nice syntax for
memory writes:

\begin{lstlisting}
// memory construction
val m = Mem(n){ UFix(width = 32) };
// memory read
val d = m(addr);
// memory write
m(addr) := x + UFix(1);
// conditional memory write
when (en) {
  m(addr) := x - UFix(1);
}
\end{lstlisting}

% TODO: rules for determining number of ports

\section{Components}

In Chisel, {\em components} are very similar to {\em modules} in
Verilog, defining a hierarchical structure in the generated circuit.
The hierarchical component namespace is accessible in downstream tools
to aid in debugging and physical layout.  A user-defined component is
defined as a {\em class} which:
\begin{itemize}
\item inherits from \code{Component},
\item contains an interface Bundle stored in a field named \code{io}, and
\item wires together subcircuits in its constructor.
\end{itemize}

Users write their own components by subclassing Component which is
defined as follows:

\begin{lstlisting}
abstract class Component {
  val io: Bundle;
  def compileV: Unit;
  def compileC: Unit;
}
\end{lstlisting}

\noindent
and defining their own \code{io} field.  For example, to define a two
input mux, we would define a component as follows:

\begin{lstlisting}
class Mux2 extends Component {
  val io = new Bundle{
    val sel = Bits(width = 1, dir = INPUT);
    val in0 = Bits(width = 1, dir = INPUT);
    val in1 = Bits(width = 1, dir = INPUT);
    val out = Bits(width = 1, dir = OUTPUT);
  };
  io.out := (io.sel & io.in1) | (~io.sel & io.in0);
}
\end{lstlisting}

\noindent
The \code{:=} assignment operator, used in the body of a
component definition, is a special operator in Chisel that wires the input of
left-hand side to the output of the right-hand side.  It is typically
used to connect an output port to its definition.

The \code{<>} operator bulk connects interfaces of opposite gender.
Bulk connections connect leaf ports of the same name to each other.
After all connections are made and the circuit is being elaborated,
Chisel warns users if ports have other than exactly one connection to them.

\begin{lstlisting}
def <> (x: Node);
\end{lstlisting}

% TODO: what is same name -- is it a pathname?

\section{BlackBox}

Black boxes allow users to define interfaces to circuits defined
outside of Chisel.  The user defines:

\begin{itemize}
\item a component as a subclass of \code{BlackBox} and
\item defines an \code{io} field with the interface.
\end{itemize}

\noindent
For example, one could define a simpel ROM blackbox as:

\begin{lstlisting}
class RomIo extends Bundle {
  val isVal = Bool(dir = INPUT);
  val raddr = UFix(width = 32, dir = INPUT);
  val rdata = Bits(width = 32, dir = OUTPUT);
}

class Rom extends BlackBox {
  val io = new RomIo();
}
\end{lstlisting}

\section{Main}

In order to construct a circuit, 
the user calls \code{chiselMain} from their main object:

\begin{lstlisting}
object chiselMain {
  def apply[T <: Component]
    (args: Array[String], 
     gen: () => T): T;
}
\end{lstlisting}

\noindent
which when run creates a C++ files named
\code{{\it component\_name}.cpp} and \code{{\it component\_name}.h} in directory specified with
\code{--target-dir {\it dir\_name}} argument.

Testing is a crucial part of circuit design.
Testing can be challenging and thus in Chisel we provide a mechanism for
testing circuits by providing test inputs and printing out results:
In order to specify Input / Output on a constructed circuit as follows:

\begin{lstlisting}
class TestIO
  (val format: String, 
   val args: Seq[Data] = null);

class Scanner extends TestIO;

class Printer extends TestIO;

object chiselMainTesting {
  def apply[T <: Component]
    (args: Array[String], gen: () => T)(
     scanner: T => TestIO, 
     printer: T => TestIO): T;
}
\end{lstlisting}

\noindent

We can use the \code{chiselMainTesting} call and \code{TestIO} objects as follows:

\begin{lstlisting}
object tutorial {
  def main(args: Array[String]) = {
    chiselMainTest(args ++ Array("--gen-harness"), 
                   () => new Mux2())(
      c => Scanner("%x %x %x", 
                   c.io.sel, c.io.in0, c.io.in1),
      c => Printer("%= %= %= %=", 
                   c.io.sel, c.io.in0, c.io.in1, 
                   c.io.out));
  }
}
\end{lstlisting}

\noindent
where the first three hex numbers from each line are read in from
standard input are bound to the \code{sel}, \code{in0},  and
\code{in1} inputs of the multiplexer circuit, and the multiplexer
inputs and \code{out} are printed out in hex format.  

Using \code{--generate-harness} for \code{Mux2}
creates a \code{Mux2-emulator.cpp}  and \code{Mux2-makefile} in directory
specified by \code{--target-dir}.  The user can then compile it using:

\begin{example}
make -f Mux2-makefile
\end{example}

\noindent

A user can test the multiplexer by creating a test file called
\code{test.out} containing:
\begin{example}
0 0 0 0
0 0 1 0
0 1 0 1
0 1 1 1
1 0 0 0
1 0 1 1
1 1 0 0
1 1 1 1
\end{example}

\noindent
and can be compared using a script as follows

\begin{example}
cut -f 1,2,3 -d " " < test | Mux2 > test.out
diff test.out test
\end{example}
 
Finally, command arguments for \code{chiselMain*} are as follows: \\

\begin{tabular}{lll}
\code{--target-dir} & target pathname prefix \\
\code{--gen-harness} & generate harness file for C++ \\
\code{--v} & generate verilog \\
\code{--vcd} & enable vcd dumping \\
\code{--debug} & put all wires in class file \\
\end{tabular}


\section{C++ Emulator}

The C++ emulator is based on a fast multiword library using
C++ templates.  A single a
word is defined by \code{val\_t} as follows: 

\lstset{language=C++}

\begin{lstlisting}
typedef uint64_t val_t;
typedef int64_t sval_t; 
typedef uint32_t half_val_t;
\end{lstlisting}

\noindent
and multiwords are defined by\code{dat\_t} as follows:

\begin{lstlisting}
template <int w>
class dat_t {
 public:
  const static int n_words;
  inline int width ( void );
  inline int n_words_of ( void );
  inline bool to_bool ( void );
  inline val_t lo_word ( void );
  inline unsigned long to_ulong ( void );
  std::string to_str ();
  static dat_t<w> rand();
  dat_t<w> ();
template <int sw> 
  dat_t<w> (const dat_t<sw>& src);
  dat_t<w> (const dat_t<w>& src);
  dat_t<w> (val_t val);
template <int sw> 
  dat_t<w> mask(dat_t<sw> fill, int n);
template <int dw> 
  dat_t<dw> mask(int n);
template <int n> 
  dat_t<n> mask(void);
  dat_t<w> operator + ( dat_t<w> o );
  dat_t<w> operator - ( dat_t<w> o );
  dat_t<w> operator - ( );
  dat_t<w+w> operator * ( dat_t<w> o );
  dat_t<w+w> fix_times_fix( dat_t<w> o );
  dat_t<w+w> ufix_times_fix( dat_t<w> o );
  dat_t<w+w> fix_times_ufix( dat_t<w> o );
  dat_t<1> operator < ( dat_t<w> o );
  dat_t<1> operator > ( dat_t<w> o );
  dat_t<1> operator >= ( dat_t<w> o );
  dat_t<1> operator <= ( dat_t<w> o );
  dat_t<1> gt ( dat_t<w> o );
  dat_t<1> gte ( dat_t<w> o );
  dat_t<1> lt ( dat_t<w> o );
  dat_t<1> lte ( dat_t<w> o );
  dat_t<w> operator ^ ( dat_t<w> o );
  dat_t<w> operator & ( dat_t<w> o );
  dat_t<w> operator | ( dat_t<w> o );
  dat_t<w> operator ~ ( void );
  dat_t<1> operator ! ( void );
  dat_t<1> operator && ( dat_t<1> o );
  dat_t<1> operator || ( dat_t<1> o );
  dat_t<1> operator == ( dat_t<w> o );
  dat_t<1> operator == ( datz_t<w> o );
  dat_t<1> operator != ( dat_t<w> o );
  dat_t<w> operator << ( int amount );
  dat_t<w> operator << ( dat_t<w> o );
  dat_t<w> operator >> ( int amount );
  dat_t<w> operator >> ( dat_t<w> o );
  dat_t<w> rsha ( dat_t<w> o);
  dat_t<w>& operator = ( dat_t<w> o );
  dat_t<w> fill_bit(val_t bit);
  dat_t<w> fill_byte
    (val_t byte, int nb, int n);
template <int dw, int n> 
  dat_t<dw> fill( void );
template <int dw, int nw> 
  dat_t<dw> fill( dat_t<nw> n );
template <int dw> 
  dat_t<dw> extract();
template <int dw> 
  dat_t<dw> extract(val_t e, val_t s);
template <int dw, int iwe, int iws> 
  dat_t<dw> extract
    (dat_t<iwe> e, dat_t<iws> s);
template <int sw> 
  dat_t<w> inject
    (dat_t<sw> src, val_t e, val_t s);
template <int sw, int iwe, int iws> 
  dat_t<w> inject
    (dat_t<sw> src, 
     dat_t<iwe> e, dat_t<iws> s);
template <int dw> 
  dat_t<dw> log2();
  dat_t<1> bit(val_t b);
  val_t msb();
template <int iw>
  dat_t<1> bit(dat_t<iw> b)
}
\end{lstlisting}

\begin{lstlisting}
template <int w, int sw> 
  dat_t<w> DAT(dat_t<sw> dat);
template <int w> 
  dat_t<w> LIT(val_t value);
template <int w> dat_t<w> 
  mux ( dat_t<1> t, dat_t<w> c, dat_t<w> a )
\end{lstlisting}

\noindent
where \code{w} is the bit width parameter.

The Chisel compiler compiles top level components into a single flattened \code{mod\_t}
class that can be created and executed:

\begin{lstlisting}
class mod_t {
 public:
  // initialize component
  virtual void init (void) { };
  // compute all combinational logic
  virtual void clock_lo (dat_t<1> reset) { };
  // commit state updates
  virtual void clock_hi (dat_t<1> reset) { };
  // print printer specd node values to stdout
  virtual void print (FILE* f) { };
  // scan scanner specd node values from stdin
  virtual bool scan (FILE* f) { return true; };
  // dump vcd file
  virtual void dump (FILE* f, int t) { };
};
\end{lstlisting}

Either the Chisel compiler can create a harness or the user can write
a harness themselves.  The following is an example of a harness for a
CPU component:

\begin{lstlisting}
#include "cpu.h"

int main (int argc, char* argv[]) {
  cpu_t* c = new cpu_t();
  int lim = (argc > 1) ? atoi(argv[1]) : -1;
  c->init();
  for (int t = 0; lim < 0 || t < lim; t++) {
    dat_t<1> reset = LIT<1>(t == 0);
    if (!c->scan(stdin)) break;
    c->clock_lo(reset);
    c->clock_hi(reset);
    c->print(stdout);
  }
}
\end{lstlisting}

\section{Verilog}

Chisel generates Verilog when the \code{--v} argument is passed into
\code{chiselMain}.  For example, from SBT, the following

\begin{example}
run --v
\end{example}

\noindent
would produce a single Verilog file named \code{{\it component-name}.v} in
the target directory.
The file will contain one module per component defined as subcomponents of
the top level component created in \code{chiselMain}.  Modules with
the same interface and body are cached and reused.

\section{Extra Stuff}

\lstset{language=scala}

\begin{example}
Lookup
Enums
MuxLookup
MuxCase
Probe
Name mangling
\end{example}

\section{Standard Library}

\begin{lstlisting}
object foldR {
  def apply[T <: Bits]
    (x: Seq[T])(f: (T, T) => T): T
}

object log2up {
  def apply(in: Int) = ceil(log(in)/log(2)).toInt
}

object ispow2 {
  def apply(in: Int) = 
    in > 0 && ((in & (in-1)) == 0)
}

object PopCount {
  def apply(in: Bits): Bits
}

object Reverse {
  def apply(in: Bits): Bits
}

object OHToUFix {
  def apply(in: Bits): UFix
  def apply(in: Seq[Bool]): UFix
}

object UFixToOH {
  def apply(in: UFix, width: Int): Bits;
}

object LFSR16 {
  def apply(increment: Bool = Bool(true)): Bits
}

object ShiftRegister {
  def apply [T <: Data](n: Int, in: T): T;
}

object Mux1H {
  def apply [T <: Data]
    (sel: Bits, in: Vec[T]): T;
  def apply [T <: Data]
    (sel: Vec[Bool], in: Vec[T]): T;
}

class ioDecoupled[+T <: Data]()(data: => T) 
    extends Bundle {
  val ready = Bool(INPUT)
  val valid = Bool(OUTPUT)
  val bits  = data.asOutput
}

class ioPipe[+T <: Data]()(data: => T) 
    extends Bundle {
  val valid = Bool(OUTPUT)
  val bits = data.asOutput
}

object PriorityEncoder {
  def apply(in: Bits): UFix;
}

object PriorityEncoderOH {
  def apply(in: Bits): UFix;
}

Arbiters

Queues

Pipes
\end{lstlisting}

% henry

% \section{Acknowlegements}
% 
% Many people have helped out in the design of Chisel, and we thank them
% for their patience, bravery, and belief in a better way.  Many
% Berkeley EECS students in the Isis group gave weekly feedback as the
% design evolved including but not limited to Yunsup Lee, Andrew
% Waterman, Scott Beamer, Chris Celio, etc.  Yunsup Lee gave us feedback
% in response to the first RISC-V implementation, called TrainWreck,
% translated from Verilog to Chisel.  Andrew Waterman and Yunsup Lee
% helped us get our Verilog backend up and running and Chisel TrainWreck
% running on an FPGA.  Brian Richards was the first actual Chisel user,
% first translating (with Huy Vo) John Hauser's FPU Verilog code to
% Chisel, and later implementing generic memory blocks.  Brian gave many
% invaluable comments on the design and brought a vast experience in
% hardware design and design tools.  Chris Batten shared his fast
% multiword C++ template library that inspired our fast emulation
% library.  Huy Vo became our undergraduate research assistant and was
% the first to actually assist in the Chisel implementation.  We
% appreciate all the EECS students who participated in the Chisel
% bootcamp and proposed and worked on hardware design projects all of
% which pushed the Chisel envelope.  We appreciate the work that James
% Martin and Alex Williams did in writing and translating network and
% memory controllers and non-blocking caches.  Finally, Chisel's
% functional programming and bit-width inference ideas were inspired by
% earlier work on a hardware description language called Gel~\cite{gel} designed in
% collaboration with Dany Qumsiyeh and Mark Tobenkin.
% 
% % \note{Who else?}
% 
% \begin{thebibliography}{50}
% \bibitem{gel} Bachrach, J., Qumsiyeh, D., Tobenkin, M. \textsl{Hardware Scripting in Gel}.
% in Field-Programmable Custom Computing Machines, 2008. FCCM '08. 16th.
% \end{thebibliography}
% 

\end{document}
