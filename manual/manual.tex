\documentclass[10pt,twocolumn]{article}
\setlength\textwidth{6.875in}
\setlength\textheight{8.875in}
% set both margins to 2.5 pc
\setlength{\oddsidemargin}{-0.1875in}% 1 - (8.5 - 6.875)/2
\setlength{\evensidemargin}{-0.1875in}
\setlength{\marginparwidth}{0pc}
\setlength{\marginparsep}{0pc}%
\setlength{\topmargin}{0in} \setlength{\headheight}{0pt}
\setlength{\headsep}{0pt}
\setlength{\footskip}{37pt}%
\setlength{\columnsep}{0.3125in}
\setlength{\columnwidth}{3.28125in}% (6.875 - 0.3125)/2 = 3.28125in
\setlength{\parindent}{1pc}
\newcommand{\myMargin}{1.00in}
\usepackage[top=\myMargin, left=\myMargin, right=\myMargin, bottom=\myMargin, nohead]{geometry}
\usepackage{epsfig,graphicx}
\usepackage{palatino}
\usepackage{fancybox}

\newenvironment{commentary}
{ \vspace{-0.1in}
  \begin{quotation}
  \noindent
  \small \em
  \rule{\linewidth}{1pt}\\
}
{
  \end{quotation}
}

\title{Chisel Manual}
\author{Jonathan Bachrach, Krste Asanovi\'{c}, John Wawrzynek \\
EECS Department, UC Berkeley\\
{\tt  \{jrb|krste|johnw\}@eecs.berkeley.edu}
}
\date{\today}

\newenvironment{example}{\VerbatimEnvironment\begin{footnotesize}\begin{Verbatim}}{\end{Verbatim}\end{footnotesize}}
\newcommand{\kode}[1]{\begin{footnotesize}{\tt #1}\end{footnotesize}}

\def\code#1{{\tt #1}}

\def\note#1{\noindent{\bf [Note: #1]}}
%\def\note#1{}

\begin{document}
\maketitle{}

% TODO: default
% TODO: enum yields Bits
% TODO: why hardware construction languages

\section{Introduction}

This document is a manual for {\em Chisel} (Constructing
Hardware In a Scala Embedded Language).  Chisel is a hardware
construction language embedded in the high-level programming language
Scala.  Chisel is really only a set of special class
definitions, predefined objects, and usage conventions within Scala,
so when you write a Chisel program you are actually writing a Scala
program.  However, for the tutorial we don't presume that you
understand how to program in Scala.  We will point out necessary Scala
features through the Chisel examples we give, and significant hardware
designs can be completed using only the material contained herein.
But as you gain experience and want to make your code simpler or more
reusable, you will find it important to leverage the underlying power
of the Scala language. We recommend you consult one of the excellent
Scala books to become more expert in Scala programming.

Chisel is still in its infancy and you are likely to encounter some
implementation bugs, and perhaps even a few conceptual design
problems.  However, we are actively fixing and improving the language,
and are open to bug reports and suggestions.  Even in its early state,
we hope Chisel will help designers be more productive in building
designs that are easy to reuse and maintain.

\section{Node}

\begin{example}
class Node {
  def getWidth: Int;
  def getNode: Node;
  def toNode: Node;
  def fromNode(Node): this.type;
}
\end{example}

\begin{example}
trait proc extends Node;
\end{example}

\subsection{Data}

\begin{example}
Node
  Data
    Wire
      IO
        Bits
          Bool
          Num
            Fix
            UFix
    Bundle
    Vec
  Delay
    Reg
    Mem
\end{example}

\begin{example}
class Data extends Node with proc {
  def flatten: Array[(String, IO)];
  def toFix: Fix;
  def toUFix: UFix;
  def toBits: Bits;
  def toBool: Bool;
  def flip: this.type;
  def asOutput: this.type;
  def asInput: this.type;
  def :=[T <: Data](data: T);
}
\end{example}

\begin{example}
class Wire extends Data;
\end{example}

\begin{example}
class IO extends Wire {
}
\end{example}

\begin{example}
class Bits extends IO {
  def unary_-(): Bits;
  def unary_~(): Bits;
  def andR(): Bool;
  def orR():  Bool;
  def ===(b: Bits): Bool;
  def != (b: Bits): Bool;
  def << (b: UFix): Bits;
  def >> (b: UFix): Bits;
  def &  (b: Bits): Bits;
  def |  (b: Bits): Bits;
  def ^  (b: Bits): Bits;
  def ## (b: Bits): Bits;
  def && (b: Bool): Bool;
  def || (b: Bool): Bool;
}
\end{example}

\begin{example}
class Bool extends Bits;
\end{example}

\begin{example}
class Num extends Bits {
  def +(b: Num): Num;
  def *(b: Num): Num;
  def -(b: Num): Num;
  def >(b: Num): Bool;
  def <=(b: Num): Bool;
  def >=(b: Num): Bool;
}
\end{example}

\begin{example}
class Fix extends Num; 
\end{example}

\begin{example}
class UFix extends Num; 
\end{example}

\subsection{Bundle}

\begin{example}
class Bundle extends Data {
  def elements: ArrayBuffer[(String, Data)];
}
\end{example}

\subsection{Vec}

\begin{example}
class Vec extends Data {
}
\end{example}

\section{Combinational}

% \subsection{Operators}

\subsection{Bit Width Inference}

Users are required to set bitwidths of ports and registers, but otherwise,
bit widths on wires are automatically inferred unless set manually by the user.
% TODO: how do you set the width explicitly?
The bit-width inference engine starts from the graph's input ports and 
calculates node output bit widths from their respective input bit widths according to the following set of rules:\\

{\footnotesize
\begin{tabular}{ll}
{\bf operation} & {\bf bit width} \\ 
\verb|z = x + y| & \verb|wz = max(wx, wy) + 1| \\
\verb+z = x - y+ & \verb|wz = max(wx, wy) + 1|\\
\verb+z = x & y+ & \verb+wz = max(wx, wy)+ \\
\verb+z = Mux(c, x, y)+ & \verb+wz = max(wx, wy)+ \\
\verb+z = w * y+ & \verb!wz = wx + wy! \\
\verb+z = x << n+ & \verb!wz = wx + maxNum(n)! \\
\verb+z = x >> n+ & \verb+wz = wx - minNum(n)+ \\
\verb+z = Cat(x, y)+ & \verb!wz = wx + wy! \\
\verb+z = Fill(n, x)+ & \verb+wz = wx * maxNum(n)+ \\
% \verb+z = x < y+ & \verb+<= > >= && || != ===+ & \verb+wz = 1+ \\
\end{tabular}
}
\\[1mm]
\noindent  
where for instance $wz$ is the bit width of wire $z$, and the \verb+&+
rule applies to all bitwise logical operations.

The bit-width inference process continues until no bit width changes.
Except for right shifts by known constant amounts, the bit-width
inference rules specify output bit widths that are never smaller than
the input bit widths, and thus, output bit widths either grow or stay
the same.  Furthermore, the width of a register must be specified by
the user either explicitly or from the bitwidth of the reset value.
From these two requirements, we can show that the bit-width inference
process will converge to a fixpoint.

\subsection{Named Wires}

\section{Sequential}

\subsection{Registers}

\begin{example}
class Reg extends Node with proc {
  def := ...
}
\end{example}

\subsection{Conditional Updates}

\begin{example}
object when {
  def apply ...
}
object unless {
  def apply ...
}
object otherwise {
  def apply ...
}
\end{example}

\section{Memory}

\subsection{ROM}

\begin{example}
object Rom {
  def apply(inits: Seq[Data])
}
class Rom {
  def read ...
}
\end{example}

\subsection{Mem}

\begin{example}
object Ram {
  def apply(depth: Int, ...)
}
class Mem {
  def read ...
}
\end{example}

\section{Ports}

\subsection{Direction}

\begin{example}
dir=INPUT
dir=OUTPUT
\end{example}


\subsection{Subclassing}

\begin{example}
extends Bundle
\end{example}

\subsection{Views}

\begin{example}
Bundle(Seq[String])
\end{example}

\section{Components}

Users write their own components by subclassing Component which is
defined as follows:

\begin{example}
abstract class Component {
  val io: IO;
  def compileV: Unit;
  def compileC: Unit;
}
\end{example}

\begin{example}
val io = ...;
\end{example}

\subsection{Bulk Connections}

\begin{example}
<>
\end{example}

\subsection{Main}

The user calls chiselMain from their main object:

\begin{example}
object chiselMain {
  def apply[T <: Component]
    (args: Array[String], 
     gen: () => T, 
     scanner: T => TestIO = null, 
     printer: T => TestIO = null): T;
}
\end{example}

Command arguments are as follows:
\begin{tabular}{lll}
\verb+--target-dir+ & target pathname prefix \\
\verb+--gen-harness+ & generate harness file for C++ \\
\verb+--v+ & generate verilog \\
\verb+--vcd+ & enable vcd dumping \\
\verb+--debug+ & put all wires in class file \\
\end{tabular}

\section{Emulator}

The C++ emulator is based on a fast multiword library using
C++ templates.  The \verb+dat_t+ represents multiple \verb+val_t+:

\begin{example}
typedef uint64_t val_t;
typedef int64_t sval_t; 
typedef uint32_t half_val_t;
\end{example}

\begin{example}
template <int w>
class dat_t {
 public:
  const static int n_words;
  inline int width ( void );
  inline int n_words_of ( void );
  inline bool to_bool ( void );
  inline val_t lo_word ( void );
  inline unsigned long to_ulong ( void );
  std::string to_str ();
  static dat_t<w> rand();
  dat_t<w> ();
template <int sw> 
  dat_t<w> (const dat_t<sw>& src);
  dat_t<w> (const dat_t<w>& src);
  dat_t<w> (val_t val);
template <int sw> 
  dat_t<w> mask(dat_t<sw> fill, int n);
template <int dw> 
  dat_t<dw> mask(int n);
template <int n> 
  dat_t<n> mask(void);
  dat_t<w> operator + ( dat_t<w> o );
  dat_t<w> operator - ( dat_t<w> o );
  dat_t<w> operator - ( );
  dat_t<w+w> operator * ( dat_t<w> o );
  dat_t<w+w> fix_times_fix( dat_t<w> o );
  dat_t<w+w> ufix_times_fix( dat_t<w> o );
  dat_t<w+w> fix_times_ufix( dat_t<w> o );
  dat_t<1> operator < ( dat_t<w> o );
  dat_t<1> operator > ( dat_t<w> o );
  dat_t<1> operator >= ( dat_t<w> o );
  dat_t<1> operator <= ( dat_t<w> o );
  dat_t<1> gt ( dat_t<w> o );
  dat_t<1> gte ( dat_t<w> o );
  dat_t<1> lt ( dat_t<w> o );
  dat_t<1> lte ( dat_t<w> o );
  dat_t<w> operator ^ ( dat_t<w> o );
  dat_t<w> operator & ( dat_t<w> o );
  dat_t<w> operator | ( dat_t<w> o );
  dat_t<w> operator ~ ( void );
  dat_t<1> operator ! ( void );
  dat_t<1> operator && ( dat_t<1> o );
  dat_t<1> operator || ( dat_t<1> o );
  dat_t<1> operator == ( dat_t<w> o );
  dat_t<1> operator == ( datz_t<w> o );
  dat_t<1> operator != ( dat_t<w> o );
  dat_t<w> operator << ( int amount );
  dat_t<w> operator << ( dat_t<w> o );
  dat_t<w> operator >> ( int amount );
  dat_t<w> operator >> ( dat_t<w> o );
  dat_t<w> rsha ( dat_t<w> o);
  dat_t<w>& operator = ( dat_t<w> o );
  dat_t<w> fill_bit(val_t bit);
  dat_t<w> fill_byte(val_t byte, int nb, int n);
template <int dw, int n> 
  dat_t<dw> fill( void );
template <int dw, int nw> 
  dat_t<dw> fill( dat_t<nw> n );
template <int dw> 
  dat_t<dw> extract();
template <int dw> 
  dat_t<dw> extract(val_t e, val_t s);
template <int dw, int iwe, int iws> 
  dat_t<dw> extract(dat_t<iwe> e, dat_t<iws> s);
template <int sw> 
  dat_t<w> inject(dat_t<sw> src, val_t e, val_t s);
template <int sw, int iwe, int iws> 
  dat_t<w> inject(dat_t<sw> src, dat_t<iwe> e, dat_t<iws> s);
template <int dw> 
  dat_t<dw> log2();
  dat_t<1> bit(val_t b);
  val_t msb();
template <int iw>
  dat_t<1> bit(dat_t<iw> b)
}
\end{example}

\begin{example}
template <int w, int sw> 
  dat_t<w> DAT(dat_t<sw> dat);
template <int w> 
  dat_t<w> LIT(val_t value);
template <int w> dat_t<w> 
  mux ( dat_t<1> t, dat_t<w> c, dat_t<w> a )
\end{example}

The Chisel compiler compiles top level components into a \verb+mod_t+
class that can be created and executed:

\begin{example}
class mod_t {
 public:
  std::vector< mod_t* > children;
  virtual void init (void) { };
  virtual void clock_lo (dat_t<1> reset) { };
  virtual void clock_hi (dat_t<1> reset) { };
  virtual void print (FILE* f) { };
  virtual bool scan (FILE* f) { return true; };
  virtual void dump (FILE* f, int t) { };
};
\end{example}

\begin{example}
environment variables
\end{example}

Either the Chisel compiler can create a harness or the user can write
a harness themselves.  The following is an example of a harness for a
CPU component:

\begin{example}
#include "cpu.h"

int main (int argc, char* argv) {
  cpu_t* cpu = new Cpu();  
  cpu->init();
  for (size_t t = 0; t < n; t++) {
    cpu->scan();
    cpu->clock_lo();
    cpu->clock_lo();
    cpu->print();
  }
}
\end{example}

\section{Verilog}

\section{Acknowlegements}

Many people have helped out in the design of Chisel, and we thank them
for their patience, bravery, and belief in a better way.  Many
Berkeley EECS students in the Isis group gave weekly feedback as the
design evolved including but not limited to Yunsup Lee, Andrew
Waterman, Scott Beamer, Chris Celio, etc.  Yunsup Lee gave us feedback
in response to the first RISC-V implementation, called TrainWreck,
translated from Verilog to Chisel.  Andrew Waterman and Yunsup Lee
helped us get our Verilog backend up and running and Chisel TrainWreck
running on an FPGA.  Brian Richards was the first actual Chisel user,
first translating (with Huy Vo) John Hauser's FPU Verilog code to
Chisel, and later implementing generic memory blocks.  Brian gave many
invaluable comments on the design and brought a vast experience in
hardware design and design tools.  Chris Batten shared his fast
multiword C++ template library that inspired our fast emulation
library.  Huy Vo became our undergraduate research assistant and was
the first to actually assist in the Chisel implementation.  We
appreciate all the EECS students who participated in the Chisel
bootcamp and proposed and worked on hardware design projects all of
which pushed the Chisel envelope.  We appreciate the work that James
Martin and Alex Williams did in writing and translating network and
memory controllers and non-blocking caches.  Finally, Chisel's
functional programming and bit-width inference ideas were inspired by
earlier work on a hardware description language called Gel~\cite{gel} designed in
collaboration with Dany Qumsiyeh and Mark Tobenkin.

% \note{Who else?}

\begin{thebibliography}{50}
\bibitem{gel} Bachrach, J., Qumsiyeh, D., Tobenkin, M. \textsl{Hardware Scripting in Gel}.
in Field-Programmable Custom Computing Machines, 2008. FCCM '08. 16th.
\end{thebibliography}

\end{document}
